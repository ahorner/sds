/*LevelMap.asCreated by: Andrew HornerContents:LevelMap defines a map containing platforms, the player character, and a set of enemies. This class containsinformation about the items it contains, listeners for Movement and Attack events, and a handler for every characterit contains, in order to apply the appropriate physics to each object.*/package map{		import character.*;	import item.*;	import sound.SoundEffect;	import fl.transitions.Tween;	import fl.transitions.TweenEvent;	import fl.transitions.easing.*;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Shape;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.utils.Dictionary;	import flash.utils.getDefinitionByName;	import flash.utils.Timer;		public class LevelMap extends MovieClip	{		protected var _width:Number;		protected var _leftBound:Number = 0;		protected var _rightBound:Number = 0;				protected var levelTiles:Array;		protected var displayTiles:Array = new Array();		protected var currentTile:int = 0;		protected var platformList:Array = new Array();				protected var pcList:Array = new Array();		protected var npcList:Array = new Array();		protected var itemList:Array = new Array();				protected var _spawnCapacity:Number = 0;		protected var _spawnList:Array = new Array();		protected var spawnTimer:Timer;				protected var dropRate:Number = 0.05;		protected var dropList:Array = new Array(new Array(0.6, "headphoneBubble"), new Array(0.1, "redBattery"), new Array(0.2, "blueBattery"), new Array(0.1, "yellowBattery"));				protected var tweens:Dictionary = new Dictionary(false);				/**********************************************		Constructor method		**********************************************/		public function LevelMap(useTiles:Array):void		{			levelTiles = useTiles;			placeTiles();						this.addEventListener("moveRequest", motionHandler);			this.addEventListener("deathEvent", deathHandler);		}				/**********************************************		The following define public methods of the 		LevelMap class.		**********************************************/				/**********************************************		Getters and Setters		**********************************************/		public override function get width():Number		{			return _width;		}				public function get leftBound():Number		{			return _leftBound;		}				public function get rightBound():Number		{			return _rightBound;		}		/*********************************************/				/*		Pre:	newChar is a DisplayObject representing some character that is desired to add to the level map		Post:	Attaches the relevant physics and attack event handlers, and adds the character to the map and character list.		*/		public function addCharacter(newChar:Object, mainChar:Boolean = false):void		{			newChar.addEventListener(Event.ENTER_FRAME, physicsHandler);			newChar.addEventListener("attackEvent", attackHandler);			newChar.addEventListener("hitEvent", newChar.hitHandler);						if (mainChar)			{				pcList.push(newChar);				this.addChildAt(newChar as DisplayObject, this.numChildren);			}			else			{				npcList.push(newChar);				newChar.setTarget(closestEnemy(newChar as DisplayObject));				this.addChildAt(newChar as DisplayObject, this.numChildren - 1);			}		}				/*		Pre:	newPlatform is a DisplayObject representing some platform that is desired to be added to the level map		Post:	Adds the platform to the map and to the level's platform list.		*/		public function addPlatform(newPlatform:DisplayObject):void		{			platformList.push(newPlatform);			this.addChild(newPlatform);		}				/*		Pre:	spawnArray is an array containing a series of probabilities for spawning  a particular monster, along				with the name of the monster attached to that probability.		Post:	Sets the level map's spawn list to the list that is passed into the function's arguments.		*/		public function set spawnList(spawnArray:Array):void		{			_spawnList = new Array();			for each (var thisSpawn:Array in spawnArray)			{				var spawn:Array = new Array();				spawn["probability"] = thisSpawn[0];				spawn["name"] = thisSpawn[1];				_spawnList.push(spawn);			}		}				/*		Pre:	newCapacity is the maximum number of enemies desired to be on-screen at one time.		Post:	Sets the level's spawn capacity to the requested amount.		*/		public function set spawnCapacity(newCapacity:int):void		{			_spawnCapacity = newCapacity;		}				/*		Pre:	newSpawnRate refers to the desired spawn rate, in seconds.		Post:	Sets the spawn timer to a timer with the desired spawn rate set as its delay value, and attaches				an event listener to the timer which calls the spawnHandler function at the desired interval.		*/		public function set spawnRate(newSpawnRate:Number):void		{			if (spawnTimer)				spawnTimer.removeEventListener(TimerEvent.TIMER, spawnHandler);			spawnTimer = new Timer(1000*newSpawnRate);			spawnTimer.addEventListener(TimerEvent.TIMER, spawnHandler);		}				/*		Pre:	None		Post:	Starts the spawn timer.		*/		public function startSpawn()		{			spawnTimer.start();		}				public function pauseMonsters():void		{			spawnTimer.stop();			var char:Character;			for each (char in npcList)			{				char.pauseCharacter();				char.removeEventListener("attackEvent", attackHandler);				char.removeEventListener(Event.ENTER_FRAME, physicsHandler);			}			//this.removeEventListener("moveRequest", motionHandler);		}				public function pauseGame():void		{			var char:Character;			for each (char in pcList)			{				char.pauseCharacter();				char.removeEventListener("attackEvent", attackHandler);				char.removeEventListener(Event.ENTER_FRAME, physicsHandler);			}			this.pauseMonsters();		}				public function resumeMonsters():void		{			spawnTimer.start();			var char:Character;			for each (char in npcList)			{				char.resumeCharacter();				char.addEventListener("attackEvent", attackHandler);				char.addEventListener(Event.ENTER_FRAME, physicsHandler);			}			//this.addEventListener("moveRequest", motionHandler);		}				public function resumeGame():void		{						var char:Character;			for each (char in pcList)			{				char.resumeCharacter();				char.addEventListener("attackEvent", attackHandler);				char.addEventListener(Event.ENTER_FRAME, physicsHandler);			}			this.resumeMonsters();					}				public function trapTile(tileNum:int):void		{			trace("trapped in " + tileNum);			_leftBound = (currentTile < tileNum) ? levelTiles[currentTile].x : levelTiles[tileNum].x;			_rightBound = (currentTile > tileNum) ? levelTiles[currentTile].x + levelTiles[currentTile].width : 													levelTiles[tileNum].x + levelTiles[tileNum].width;		}				/**********************************************		The following define private methods of the 		LevelMap class.		**********************************************/				/*		Pre:	e refers to a TimerEvent.TIMER event, which is tied to the LevelMap's spawn timer		Post:	If the list of enemies does not contain enough enemies to fill the spawn quota (spawnCapacity), this function				spawns a new monster at some probability based on the spawn list passed in by the game.		*/		protected function spawnHandler(e:TimerEvent):void		{			if (npcList.length < _spawnCapacity)			{				var monsterChoice:Number = Math.random();				var curProbability:Number = 0;				for each (var spawn:Array in _spawnList)				{					curProbability += spawn["probability"];					if (curProbability > monsterChoice)					{						var monster:Monster = new (Class(getDefinitionByName(spawn["name"])))();						var spawnPoint = globalToLocal(new Point(Math.random()*stage.stageWidth, 10));						monster.x = spawnPoint.x;						monster.y = spawnPoint.y;						addCharacter(monster);						return;					}				}			}		}				/*		Pre:	dropX refers to the x position at which an item should be placed				dropY refers to the y position at which an item should be placed		Post:	Calculates whether or not a drop should occur, and if so, places an item at the desired location,				with the item selected at some specified probability from the level's drop list.		*/		protected function dropHandler(dropX:Number, dropY:Number):void		{			var isDrop:Boolean = (Math.random() < dropRate);			if (isDrop)			{				var itemChoice:Number = Math.random();				var curProbability:Number = 0;				for each (var drop in dropList)				{					curProbability += drop[0];					if (curProbability > itemChoice)					{						var dropItem:PowerUp = new (Class(getDefinitionByName(drop[1])))();						dropItem.x = dropX;						dropItem.y = dropY;						itemList.push(dropItem);						this.addChild(dropItem);						return;					}				}			}		}				/*		Pre:	None		Post:	The tiles in the levelTiles array are placed in their proper locations;				the tiles that are initially on display are added to the stage.		*/		protected function placeTiles():void		{			_width = 0;			this._leftBound = 0;						for (var i:uint = 0; i < levelTiles.length; i++)			{				if (i == 0)					levelTiles[i].x = 0;				else					levelTiles[i].x = levelTiles[i - 1].x + levelTiles[i - 1].width;									_width = levelTiles[i].x + levelTiles[i].width;				this._rightBound = _width;								for (var j:uint = 1; j < levelTiles[i].numChildren; j++)					platformList.push(levelTiles[i].getChildAt(j));			}							displayTiles["left"] = null;			displayTiles["center"] = levelTiles[0];			this.addChildAt(displayTiles["center"], 0)			if (levelTiles.length > 1)			{				displayTiles["right"] = levelTiles[1];				this.addChildAt(displayTiles["right"], 0);			}			else				displayTiles["right"] = null;		}				/*		Pre:	centerTile is a reference to an element in the tileList for the level		Post:	If the passed center tile is the same as the current center tile, no changes occur;				if the passed center tile is different from the current center tile, the display tiles are updated				in order to reposition the passed tile as the new center tile.		*/		protected function updateTiles(centerTile:int):void		{			if (currentTile == centerTile)				return;			else if (centerTile < currentTile)			{				if (displayTiles["right"])					if (this.contains(displayTiles["right"]))						this.removeChild(displayTiles["right"]);				displayTiles["right"] = displayTiles["center"];				displayTiles["center"] = displayTiles["left"];				if (centerTile > 0)				{					displayTiles["left"] = levelTiles[centerTile - 1];					this.addChildAt(displayTiles["left"], 0)				}			}			else if (centerTile > currentTile)			{				if (displayTiles["left"])					if (this.contains(displayTiles["left"]))						this.removeChild(displayTiles["left"]);				displayTiles["left"] = displayTiles["center"];				displayTiles["center"] = displayTiles["right"];				if (centerTile < levelTiles.length - 1)				{					displayTiles["right"] = levelTiles[centerTile + 1];					this.addChildAt(displayTiles["right"], 0);				}			}						if (centerTile == levelTiles.length - 1)				displayTiles["right"] = null;			else if (centerTile == 0)				displayTiles["left"] = null;						currentTile = centerTile;						this.dispatchEvent(new LevelEvent(currentTile));		}				/*		Pre:	e is a Movement Event containing information about the desired location for movement of a character on the level map		Post:	Moves the character to the deisred position if it is a valid one, otherwise ignores the request.				Updates the currently displayed tiles to ensure that only the nearby tiles are displayed.		*/		protected function motionHandler(e:MovementEvent):void		{			if (e.target is Hero)			{				var placeX = e.useX;					if (displayTiles["left"] == null && placeX < displayTiles["center"].x + 1)					placeX = displayTiles["center"].x + 1;				else if (displayTiles["right"] == null && placeX >= displayTiles["center"].x + displayTiles["center"].width - 1)					placeX = displayTiles["center"].x + displayTiles["center"].width - 1;									if (placeX < _leftBound + 1)					placeX = _leftBound + 1;				else if (placeX > _rightBound - 1)					placeX = _rightBound - 1;								e.target.x = placeX;				e.target.y = e.useY;								var centerTile:Number = currentTile;				if (displayTiles["left"] != null && e.target.x < displayTiles["left"].x + displayTiles["left"].width && e.target.x > displayTiles["left"].x)					centerTile--;				else if (displayTiles["right"] != null && e.target.x > displayTiles["right"].x && e.target.x < displayTiles["right"].x + displayTiles["right"].width)					centerTile++;								updateTiles(centerTile);			}			else			{				e.target.x = e.useX;				e.target.y = e.useY;			}						if (e.target is Projectile)			{				var globalCoords:Point = localToGlobal(new Point(e.target.x, e.target.y));								if (globalCoords.x > stage.stageWidth ||					globalCoords.x < 0 ||					globalCoords.y > stage.stageHeight ||					globalCoords.y < 0)				{					this.removeChild(e.target as DisplayObject)					return;				}								var enemyList:Array;								if (pcList.indexOf(e.target.attackSource) == -1)					enemyList = pcList;				else					enemyList = npcList;									for each (var char in enemyList)					if (char.hitRegion.hitTestObject(e.target))					{						var projectileSound:SoundEffect = new SoundEffect("magicHit", localToGlobal(new Point(char.x, char.y)).x, 0.4)						char.x += e.target.knockback;						char.dispatchEvent(new HitEvent(e.target.power));						this.removeChild(e.target as DisplayObject);						break;					}			}		}					/*		Pre:	e is a Death Event containing information regarding a character whose health has dropped to zero.		Post:	Applies a fading tween to the dead character, causing it to fade out, and attaches a listener to handle				the end of the tween.		*/		protected function deathHandler(e:DeathEvent):void		{			if (!(e.target is Hero))			{				e.target.removeEventListener("hitEvent", e.target.hitHandler);				var tween:Tween = new Tween(e.target, "alpha", Strong.easeIn, 1, 0, .5, true);				tween.addEventListener(TweenEvent.MOTION_FINISH, tweenHandler);				tweens[tween] = tween;			}		}				/*		Pre:	e is a TweenEvent referring to the end of a dead character's fading tween.		Post:	The character is removed from the list of characters, and the tween is removed from the list of tweens.		*/		protected function tweenHandler(e:TweenEvent):void		{			e.target.obj.removeEventListener(Event.ENTER_FRAME, physicsHandler);			dropHandler(e.target.obj.x, e.target.obj.y);			this.removeChild(e.target.obj);						var charIndex:Number = pcList.indexOf(e.target.obj);			if (charIndex == -1)				npcList.splice(npcList.indexOf(e.target.obj), 1);			else				pcList.splice(charIndex, 1);							e.target.removeEventListener(TweenEvent.MOTION_FINISH, tweenHandler);			tweens[e.target] = null;			delete tweens[e.target];		}				/*		Pre:	e is an ENTER_FRAME event that is applied to some character on the level map		Post:	Applies all relevant physics to the character referenced by the event.		*/		protected function physicsHandler(e:Event):void		{						if (e.target is Hero)				for each (var itemObj in itemList)					if (e.target.hitRegion.hitTestObject(itemObj))						grabHandler(itemObj);						var landed:Boolean = false;						e.target.dY += 5;						var curY:Number = e.target.y;			var curX:Number = e.target.x;			var curdY:Number = e.target.dY;						var globalPoint:Point = this.localToGlobal(new Point(curX, curY));						var platY:Number;			var platHeight:Number;						for each (var platform:DisplayObject in platformList)			{				platY = platform.y;				platHeight = platform.height;								if (curX > platform.x + platform.parent.x && curX < platform.x + platform.parent.x + platform.width)				{					if (curY < platY + platHeight && curdY > 0)					{						if (curY + curdY > platY + platHeight ||							(curY + curdY < platY + platHeight && curY + curdY > platY))						{							curdY = platY - curY;							var isOn:Boolean = platform.hitTestPoint(globalPoint.x, globalPoint.y + curdY, true);							while(!isOn && curdY < e.target.dY)							{								curdY++;								isOn = platform.hitTestPoint(globalPoint.x, globalPoint.y + curdY, true);							}							if (isOn)							{								e.target.y += curdY;								e.target.dY = 0;							}						}					}				}			}						e.target.y += e.target.dY;						if (e.target.y > stage.stageHeight)			{				e.target.y = stage.stageHeight;				e.target.dY = 0;			}						if (e.target.dY == 0)				landed = true;						if (landed)			{				e.target.isGrounded = true;			}			else				e.target.isGrounded = false;		}				/*		Pre:	itemObj is a reference to some Item in the level.		Post:	Removes the item from the map and dispatches a grab event for the main game to handle.		*/		protected function grabHandler(itemObj:Item):void		{			this.removeChild(itemObj);			itemList.splice(itemList.indexOf(itemObj), 1);			var grabEvent:ItemEvent = new ItemEvent("grabEvent", itemObj);			this.dispatchEvent(grabEvent);		}				/*		Pre:	e is an Attack Event containing information about the user of a skill, that skill's hitbox, and that skill's power		Post:	Applies all appropriate damages and effects to the characters that are in the attack's area of effect;				creates a projectile with the desired traits if the attack is a projectile attack.		*/		protected function attackHandler(e:AttackEvent):void		{			var hitSound:SoundEffect;			var useX:Number = e.target.x;			var useY:Number = e.target.y;			var collision:Boolean;			var char:DisplayObject;						var knockback:Number = e.knockback;						if (e.attackType == "hitBullet")			{				var bullet:Projectile = new (Class(getDefinitionByName(e.attributeList[4] as String)));				bullet.dX = e.attributeList[2];				bullet.dY = e.attributeList[3];				bullet.power = e.power;				bullet.knockback = knockback;				bullet.scaleX *= Math.abs(knockback)/knockback;								bullet.attackSource = e.target as DisplayObject;				bullet.x = e.target.x + e.attributeList[0];				bullet.y = e.target.y + e.attributeList[1];				this.addChild(bullet);			}			else if (pcList.indexOf(e.target) != -1)			{				if (e.attackType == "hitTarget")					char = closestEnemy(e.target as DisplayObject);				else				{					for each(char in npcList)					{						if (e.attackType == "hitBox")							collision = testHitBox(new Array((useX+e.attributeList[0]), (useY+e.attributeList[1]), (useX+e.attributeList[2]), (useY+e.attributeList[3])), char as DisplayObject);						else if (e.attackType == "hitRadius")						{							collision = testHitRadius(new Array((useX+e.attributeList[0]), (useY+e.attributeList[1]), e.attributeList[2]), char as DisplayObject);							if (useX + e.attributeList[0] > char.x)								knockback = -Math.abs(knockback);							else								knockback = Math.abs(knockback);						}						if (collision)						{							char.dispatchEvent(new HitEvent(e.power));							if (e.power > 0)								hitSound = new SoundEffect("hitSound", localToGlobal(new Point(char.x, char.y)).x, 0.2);							char.x += knockback;						}					}				}			}			else			{				for each(char in pcList)				{					if (e.attackType == "hitBox")						collision = testHitBox(new Array((useX+e.attributeList[0]),(useY+e.attributeList[1]),(useX+e.attributeList[2]),(useY+e.attributeList[3])), char as DisplayObject);					else if (e.attackType == "hitRadius")					{							collision = testHitRadius(new Array((useX+e.attributeList[0]),(useY+e.attributeList[1]), e.attributeList[2]), char as DisplayObject);							if (useX + e.attributeList[0] > char.x)								knockback = -Math.abs(knockback);							else								knockback = Math.abs(knockback);					}					if (collision)					{						char.dispatchEvent(new HitEvent(e.power));						if (e.power > 0)							hitSound = new SoundEffect((char as Hero).gender+"Hit", localToGlobal(new Point(char.x, char.y)).x, 0.2);						char.x += knockback;					}				}			}		}				/*		Pre:	hitBox is an array containing the upper left and lower right coordinates of a defined hitbox				target is a reference to the DisplayObject representing the character being tested for collision with the attack		Post:	Returns true if the hitbox coincides with the target				Returns false, otherwise.		*/		protected function testHitBox(hitBox:Array, target:DisplayObject):Boolean		{			var drawBox:Shape = new Shape();			//drawBox.graphics.beginFill(0xCCFF00);			drawBox.graphics.drawRect(hitBox[0], hitBox[1], hitBox[2]-hitBox[0], hitBox[3]-hitBox[1]);			this.addChild(drawBox);						if (drawBox.hitTestObject((target as Character).hitRegion))			{				this.removeChild(drawBox);				return true;			}						this.removeChild(drawBox);			return false;		}				/*		Pre:	hitCircle is an array containing the center of a defined hit-circle and its radius				target is a reference to the DisplayObject representing the character being tested for collision with the attack		Post:	Returns true if the hitCircle coincides with the target				Returns false, otherwise.		*/		protected function testHitRadius(hitCircle:Array, target:DisplayObject):Boolean		{			var drawCircle:Shape = new Shape()			//drawCircle.graphics.beginFill(0xCCFF00);			//drawCircle.graphics.drawCircle(hitCircle[0], hitCircle[1], hitCircle[2]);			//addChild(drawCircle);			var targetRadius = target.height/2;			var distance = Math.sqrt(Math.pow(target.x - hitCircle[0], 2) + Math.pow(target.y - targetRadius - hitCircle[1], 2));						if (distance <= targetRadius + hitCircle[2])				return true;						return false;		}				/*		Pre:	attackSource is a reference to the Character seeking its closest opponent		Post:	Returns a reference to the closest opponent of Character, based on whether the Character is in pcList or				npcList.		*/		protected function closestEnemy(attackSource:DisplayObject):DisplayObject		{			var minDistance:Number = 9999;			var distance:Number;			var closestEnemy:DisplayObject;			var char:DisplayObject;			var enemyList:Array;						if (pcList.indexOf(attackSource) != -1)				enemyList = npcList;			else				enemyList = pcList;							for each (char in enemyList)			{				distance =  Math.sqrt(Math.pow(attackSource.x - char.x, 2) + Math.pow(attackSource.y - char.y, 2));				if (distance < minDistance)				{					closestEnemy = char;					minDistance = distance;				}			}							return closestEnemy as DisplayObject;		}		/**********************************************		**********************************************/	}	}