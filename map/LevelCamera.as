/*LevelCamera.asCreated by: Andrew HornerContents:LevelCamera defines a view manager for the LevelMap class. The desired level map is chosen to display in the viewfinder,which is managed through the scrollRect attribute of the LevelCamera, and optimized for display with the cacheAsBitmap attribute. A focus object is defined in order to manage the scrollRect relative to the level map's position..*/package map{		import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.events.Event;	import flash.geom.Rectangle;		public class LevelCamera extends MovieClip	{				//References to the background map and focus object		protected var _bgMap:LevelMap;		protected var _focus:DisplayObject;				//Values used to buffer the edges of the camera display 		protected var displayBuffer:Number = 70;		protected var edgeBuffer:Number = 100;		protected var crawlBuffer:Number = 100;				protected var originalX:Number = 0;		protected var destinationX:Number;		protected var panSpeed:Number;		protected var panInstruction:String = "none";				/**********************************************		Constructor method		**********************************************/		public function LevelCamera(windowWidth:int = 600, windowHeight:int = 480):void		{			this.x -= displayBuffer;			this.cacheAsBitmap = true;			this.scrollRect = new Rectangle(0, 0, windowWidth + (2 * displayBuffer), windowHeight);		}				/**********************************************		The following define public methods of the 		LevelMap class.		**********************************************/				/**********************************************		Getters and setters		**********************************************/		public function set bgMap(useMap:LevelMap):void		{			if (_bgMap)				this.removeChild(_bgMap);			_bgMap = useMap;			this.addChild(_bgMap);		}				public function set focus(useFocus:DisplayObject):void		{			if (_focus)				_focus.removeEventListener(Event.ENTER_FRAME, updateView);			_focus = useFocus;			_focus.addEventListener(Event.ENTER_FRAME, updateView);		}		/*********************************************/				public function pauseGame():void		{			_focus.removeEventListener(Event.ENTER_FRAME, updateView);		}				public function resumeGame():void		{			_focus.addEventListener(Event.ENTER_FRAME, updateView);		}				public function panCamera(newPanSpeed:Number = 5, newDestinationX:Number = 0):void		{			if (newDestinationX != 0)				destinationX = newDestinationX;			else				destinationX = originalX;							originalX = this.scrollRect.x;			panSpeed = newPanSpeed * (destinationX - originalX)/Math.abs(destinationX - originalX);						if (panSpeed > 0)				panInstruction = "right";			else				panInstruction = "left";		}		/**********************************************		**********************************************/				/**********************************************		The following define protected methods of the 		LevelMap class.		**********************************************/				/*		Pre:	e is a reference to an Event.ENTER_FRAME event attached to this class's focus object		Post:	Updates the camera's view relative to the position of the focus object on the current level map.				If the focus is within edgeBuffer of the edge of the screen, match their position.				Otherwise, if the focus is within crawlBuffer of the edge of the screen, incrementally move toward				their position.		*/		protected function updateView(e:Event):void		{			var rect:Rectangle = this.scrollRect;						if (panInstruction != "none")			{				rect.x += panSpeed;				this.scrollRect = rect;								if ((panInstruction == "right" && rect.x >= destinationX) ||					(panInstruction == "left" && rect.x <= destinationX))				{					this.dispatchEvent(new Event(Event.COMPLETE));					panInstruction = "none";				}								return;			}						var currentBufferOverage:Number = _focus.x - rect.x - rect.width + displayBuffer + edgeBuffer;			var currentBufferUnderage:Number = rect.x - _focus.x + displayBuffer + edgeBuffer;						if (currentBufferOverage + crawlBuffer > 0)			{				if (currentBufferOverage > 0)					rect.x += currentBufferOverage;				else					rect.x++;									if (rect.x + rect.width > _bgMap.rightBound + displayBuffer)					rect.x = _bgMap.rightBound - rect.width + displayBuffer;							}			else if (currentBufferUnderage + crawlBuffer > 0)			{				if (currentBufferUnderage > 1)					rect.x -= currentBufferUnderage;				else					rect.x--;									if (rect.x < _bgMap.leftBound + -displayBuffer)					rect.x = _bgMap.leftBound - displayBuffer;			}							this.scrollRect = rect;		}		/**********************************************		**********************************************/	}	}		