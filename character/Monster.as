/*Monster.asCreated by: Andrew HornerContents:Monster defines a subclass of Character which is controlled by an AI. It contains a timer, and a listener for that timer which causesthe Monster to update its current action relative to its designated target. The think function can be overridden by extensions of thisclass, allowing for a more advanced intelligence than the default "seek and destroy" state machine.*/package character{		import flash.display.DisplayObject;	import flash.display.Shape;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.utils.Timer;		public class Monster extends Character	{				protected var target:DisplayObject;		protected var thinkTimer:Timer;		protected var healthBar:Shape = new Shape();		protected var attackRange:Number = 150;				protected var activeCommands:Array = new Array();				/**********************************************		Constructor method		**********************************************/		public function Monster():void		{			super();			maxHealth = 10;			_health = maxHealth;			setThinkSpeed(.5);						var useSkill:Skill = new Skill();			useSkill.addSegment(Skill.makeSkillSegment(8, 0, 0, new Array(0, 0, 0, 0)));			useSkill.addSegment(Skill.makeSkillSegment(1, 7, 25, new Array(18, -139, 120, -37)));			useSkill.addSegment(Skill.makeSkillSegment(1, 7, 25, new Array(34, -107, 154, -47)));			useSkill.addSegment(Skill.makeSkillSegment(1, 7, 25, new Array(14, -107, 167, -13)));			useSkill.addSegment(Skill.makeSkillSegment(3, 0, 0, new Array(0, 0, 0, 0)));			specificCommands["attack"] = useSkill;					}				/**********************************************		The following define public methods of the 		Monster class.		**********************************************/				/*		Pre:	thinkSpeed is a number referring to the delay, in seconds, that should occur between decisions made by the character		Post:	thinkTimer is updated to reflect the new delay specified by thinkSpeed.		*/		public function setThinkSpeed(thinkSpeed:Number):void		{			if (thinkTimer)				if (thinkTimer.hasEventListener(TimerEvent.TIMER))					thinkTimer.removeEventListener(TimerEvent.TIMER, think);			thinkTimer = new Timer(thinkSpeed*1000);			thinkTimer.addEventListener(TimerEvent.TIMER, think);		}				/*		Pre:	newTarget is a reference to a display object in the same container as this object		Post:	Sets this character's target to newTarget.		*/		public function setTarget(newTarget:DisplayObject):void		{			target = newTarget;		}				/*		Pre:	e is a reference to a TimerEvent.TIMER		Post:	Updates the character's state based on the position of the character's current target		*/		protected function think(e:TimerEvent):void		{			var distX:Number = this.x - target.x;			var distY:Number = this.y - target.y;			if (distX > 0)			{					curDirection = "left";				this.scaleX = -_scale;			}			else			{				curDirection = "right";				this.scaleX = _scale;			}						if (Math.abs(distX) + Math.abs(distY) > attackRange*scale && 				distY > -attackRange*scale && 				Math.abs(distX) < attackRange*scale && 				_isGrounded)			{				_dY = -_jumpHeight;				_isGrounded = false;				changeState("jump");			}			else if (Math.abs(distX) + Math.abs(distY) > attackRange*scale)			{				if (curState != "walk")				{					changeState("walk");				}			}			else			{				_dX = 0;				changeState("attack");				thinkTimer.stop();				this.removeEventListener(Event.ENTER_FRAME, everyFrame);				this.addEventListener(Event.ENTER_FRAME, executeSkill);			}						}				public override function pauseCharacter():void		{			thinkTimer.stop();			super.pauseCharacter();		}				public override function resumeCharacter():void		{			super.resumeCharacter();			thinkTimer.start()		}		/**********************************************		**********************************************/				/**********************************************		The following define private methods of the 		Character class.		**********************************************/				/*		Pre:	curAction refers to the action that is currently being performed by the character		Post:	Updates the character to the proper state based on their current state;				dispatches a movement event if the character is moving.		*/		protected function updateAction(curAction:String):void		{			if (curAction == "idle"){				for (var command in activeCommands)					if (activeCommands[command])					{						if (command == "left" || command=="right")						{							curDirection = command;							changeState("walk");						}						curAction = command;						break;					}			}			if (curAction == "walk")				_dX = Math.abs(this.scaleX)/this.scaleX * walkSpeed;			var moveMe:MovementEvent = new MovementEvent(this, this.x + _dX, this.y + _dY);			this.dispatchEvent(moveMe);		}				/*		Pre:	e is an Event.ENTER_FRAME event		Post:	The character's state is updated based on its current animation and state;				if the character is currently idle, the thinkTimer is started in order to decide on a new action.		*/		protected override function everyFrame(e:Event):void		{			updateHealthBar();						if (health <= 0 && !isDead)			{				isDead = true;				thinkTimer.removeEventListener(TimerEvent.TIMER, think);				changeState("dying");			}						if (!isDead)			{				updateAction(curState);			}						if (this.currentLabel == "end"+curState)			{				if (curState == "walk" || curState == "dead")					this.gotoAndPlay(curState);				else if (curState == "dying")				{					var deathEvent:DeathEvent = new DeathEvent(this);					this.dispatchEvent(deathEvent);					changeState("dead");				}				else					changeState("idle");			}						if (curState == "idle" && !isDead)			{				thinkTimer.start();			}		}				/*		Pre:	None		Post:	The character's health bar is updated to reflect the current percentage of their max health remaining 		*/		protected function updateHealthBar():void		{			if (this.contains(healthBar))				this.removeChild(healthBar);			healthBar = new Shape();			healthBar.graphics.beginFill(0x00FF00);			healthBar.graphics.drawRect(0, 0, 100*_health/maxHealth, 8);			healthBar.graphics.beginFill(0xFF0000);			healthBar.graphics.drawRect(100*_health/maxHealth, 0, 100*(1-_health/maxHealth), 8);			healthBar.x = -50;			healthBar.y = 10;			this.addChild(healthBar);		}						/*		Pre:	e is an Event.ENTER_FRAME event, and the character is currently in an attacking state		Post:	The currently selected skill's segments are cycled through, as the character's attack animation is cycled.		*/		protected override function executeSkill(e:Event):void		{			super.executeSkill(e);						updateHealthBar();						if (this.currentLabel == "end"+curState || this.health == 0)			{				if (this.health == 0)					changeState("dying");				else					changeState("idle");				curSegmentFrame = 1;				curSkillSegment = 0;				isAttacking = false;				this.removeEventListener(Event.ENTER_FRAME, executeSkill);				this.addEventListener(Event.ENTER_FRAME, everyFrame);								if (curDirection == "left")					this.scaleX = -_scale;				else					this.scaleX = _scale;			}					}		/**********************************************		**********************************************/	}	}