/*Hero.asCreated by: Andrew HornerContents:Hero defines a subclass of Character which contains Genre objects. The Hero possesses the ability to transform between these Genres and access the abilities that have been unlocked for each Genre. The Hero also possesses methods for handling user input in orderto allow the player to manipulate these Genres in order to play the game.*/package character{		import flash.display.MovieClip;	import flash.display.Shape;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;		public class Hero extends Character	{				//Semi-permanent properties that are only updated between genres		protected var displayGenre:Genre = new Genre();		protected var genreList:Array = new Array();		protected var commandList:Array = new Array();		protected var activeCommands:Array = new Array();		protected var _gender:String = "boy";		protected var _curGenre:String = "none";				//Transient variables used for managing state and appearance		protected var curTransform:String = "disable";				/**********************************************		Constructor method		**********************************************/		public function Hero():void		{			super();		}				/**********************************************		The following define public methods of the 		Hero class.		**********************************************/				/**********************************************		Getters and Setters		**********************************************/		public function set gender(newGender:String):void		{			_gender = newGender;		}				public function get gender():String		{			return _gender;		}				public function get curGenre():String		{			return _curGenre;		}		/*********************************************/				/*		Pre:	newgenre is a String value containing the name of a valid genre.				OR				newGenre is a valid reference to an object of the Genre class.		Post:	Appends either the referenced Genre instance, or a new instance of the named class, to the genre list.		*/		public function addGenre(newGenre:*):void		{			if (newGenre is String)				genreList[newGenre] = new (Class(getDefinitionByName(newGenre+_gender)))();			else if (newGenre is Genre)				genreList[getQualifiedClassName(newGenre)] = newGenre;		}				/*		Pre:	genreName is a String value referring to the Genre that is desired to transform into.		Post:	The character transitions to the requested genre type.		*/		public function changeGenre(genreName:String):void		{			curTransform = genreName;			if (this.contains(displayGenre) && !isAttacking && !isDead)			{				isAttacking = false;				this.removeEventListener(Event.ENTER_FRAME, executeSkill);				this.removeEventListener(Event.ENTER_FRAME, everyFrame);				changeState("transform");				this.addEventListener(Event.ENTER_FRAME, transformGenre);			}			else if (!isAttacking && !isDead)			{				_curGenre = genreName;				for each(var genre in genreList)					if (getQualifiedClassName(genre) == genreName+_gender)					{						displayGenre = genre;						walkSpeed = genre.walkSpeed;						jumpHeight = genre.jumpHeight;						break;					}				specificCommands = new Array();				for each(var skill in displayGenre.skillList)					specificCommands[skill.name] = skill;				this.addChild(displayGenre);				changeState("idle");				var hitBox:Shape = new Shape();				hitBox.graphics.drawRect(0, 0, (this.width/_scale)-hitRegionBuffer, (this.height/_scale)-hitRegionBuffer);				hitRegion = hitBox;								this.addEventListener(Event.ENTER_FRAME, everyFrame);			}		}				/*		Pre:	commands is a reference to an associative array, containing labels for the various commands that the player will enter throughout the game		Post:	The commandList is updated to reflect the new commands being passed in by the game.		*/		public function addCommands(commands:Array):void		{			for (var command in commands){				commandList[commands[command]] = command;				activeCommands[commands[command]] = false;			}		}				/*		Pre:	genreName is a String referring to the genre to which the requested skill should be added				newSkill is a reference to the Skill object that should be added to the requested genre		Post:	The skill is appended to the appropriate genre's skill list.		*/		public function addSkill(genreName:String, newSkill:Skill):void		{			genreList[genreName].addSkill(newSkill);		}				/*		Pre:	e is a Keyboard Event containing information about user input		Post:	Activates the command in the manager array, and determines how to appropriately handle state changes based on user inputs		*/		public function keyDownHandler(e:KeyboardEvent):void		{			if (curState != "transform" && !isDead)			{				var command = commandList[e.keyCode];				activeCommands[command] = true;								if (command == "left" || command == "right")						if (command != curDirection)							curDirection = command;											if (curState != "crouch" && curState != "crouched" && !isAttacking)				{					if (command == "left" || command == "right"){						if (curState != "walk")							changeState("walk");						if (curDirection == "left")							this.scaleX = -_scale;						else							this.scaleX = _scale;					}					else if (command == "jump" && _isGrounded)					{						_dY = -_jumpHeight;						_isGrounded = false;						changeState("jump");					}					else if (command == "crouch")					{						_dX = 0;						changeState("crouch");					}					else if (command != curState && command != "jump" && isValid(command))					{						_dX = 0;						activeCommands["left"] == false;						activeCommands["right"] == false;						changeState(command);						this.removeEventListener(Event.ENTER_FRAME, everyFrame);						isAttacking = true;						this.addEventListener(Event.ENTER_FRAME, executeSkill);					}				}			}		}				/*		Pre:	e is a Keyboard Event containing information about user input.		Post:	Deactivates the command in the manager array, and determines how to appropriately end the state transitions		*/		public function keyUpHandler(e:KeyboardEvent):void		{			var command = commandList[e.keyCode];			activeCommands[command] = false;			if (command == "left" || command == "right"){				_dX = 0;				if (curState == "walk"){					changeState("idle");				}			}			if (command == "crouch" && (curState == "crouch" || curState == "crouched"))				changeState("rise");		}				public override function pauseCharacter():void		{			if (isAttacking)				this.removeEventListener(Event.ENTER_FRAME, executeSkill);			else				this.removeEventListener(Event.ENTER_FRAME, everyFrame);			displayGenre.stop();		}				public override function resumeCharacter():void		{			displayGenre.play();			if (isAttacking)				this.addEventListener(Event.ENTER_FRAME, executeSkill);			else			{				this.changeState("idle");				activeCommands["left"] = false;				activeCommands["right"] = false;				_dX = 0;				this.addEventListener(Event.ENTER_FRAME, everyFrame);			}		}		/**********************************************		**********************************************/				/**********************************************		The following define private methods of the 		Hero class.		**********************************************/				/*		Pre:	newState refers to a valid state that is associated with an animation in the movie clip		Post:	The clip's current state is updated, and its display updates to reflect this change		*/		protected override function changeState(newState:String):void		{			curState = newState;			displayGenre.gotoAndPlay(curState);		}				/*		Pre:	e is an ENTER_FRAME event applied to the current displayGenre		Post:	The displayed genre will cycle through its transformation animation, and the genre				will change to the requested genre once the animation is complete.		*/		protected function transformGenre(e:Event)		{			if (displayGenre.currentLabel == "endtransform")			{				this.removeEventListener(Event.ENTER_FRAME, transformGenre);				this.removeChild(displayGenre);								_curGenre = curTransform;								for each(var genre in genreList)					if (getQualifiedClassName(genre) == curTransform+_gender)					{						displayGenre = genre;						attack = 1;						defense = genre.defense;						walkSpeed = genre.walkSpeed;						jumpHeight = genre.jumpHeight;						break;					}										specificCommands = new Array();				for each(var skill in displayGenre.skillList)					specificCommands[skill.name] = skill;									this.addChild(displayGenre);				var hitBox:Shape = new Shape();				hitBox.graphics.drawRect(0, 0, (this.width/_scale)-hitRegionBuffer, (this.height/_scale)-hitRegionBuffer);				hitRegion = hitBox;				changeState("reveal");								curTransform = "disable";								this.addEventListener(Event.ENTER_FRAME, everyFrame);			}		}				/*		Pre:	query is a String referring to a potential command		Post:	Returns true if query refers to a valid command for the specific genre in play,				returns false if otherwise.		*/		protected function isValid(query:String):Boolean		{			for each(var command in commandList)				if (command == query)				{					if (query == "left" || query == "right" || query == "jump" || query == "crouch")						return true;					else						for (var skill in specificCommands)							if (skill == query)								return true;				}			return false;		}				/*		Pre:	curAction refers to a valid current state of the 		Post:	Updates the character based on what the current state is, dispatching movement events 		in cases where the character needs to move, and picking up on old buffered commands when necessary		*/		protected function updateAction(curAction:String):void		{			if (curAction == "idle"){				for (var command in activeCommands)					if (activeCommands[command])					{						if (command == "left" || command=="right")						{							curDirection = command;							changeState("walk");						}						curAction = command;						break;					}			}			if (curAction == "walk")				_dX = Math.abs(this.scaleX)/this.scaleX * _walkSpeed;			var moveMe:MovementEvent = new MovementEvent(this, this.x + _dX, this.y + _dY);			this.dispatchEvent(moveMe);		}				/*		Pre:	e is an ENTER_FRAME Event, causing the movie clip to update on every frame		Post:	The clip cycles through, updating state according to the character's current state.		*/		protected override function everyFrame(e:Event):void		{			if (health <= 0 && !isDead)			{				isDead = true;				changeState("dying");				this.removeEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);				this.removeEventListener(KeyboardEvent.KEY_UP, keyUpHandler);			}						if (!isDead)			{				updateAction(curState);			}						if (displayGenre.currentLabel == "end"+curState)			{				if (curState == "walk" || curState == "crouched" || curState == "dead")					displayGenre.gotoAndPlay(curState);				else if (curState == "crouch")					changeState("crouched");				else if (curState == "transform")					changeState("reveal");				else if (curState == "dying")					changeState("dead");				else					changeState("idle");							}					}				/*		Pre:	e is an ENTER_FRAME Event, causing the movie clip to update on every frame		Post:	The clip cycles through its skill animation, dispatching AttackEvents to the level map in order to interact with enemies		*/		protected override function executeSkill(e:Event):void		{						super.executeSkill(e);						if (displayGenre.currentLabel == "end"+curState || this.health == 0)			{				if (this.health == 0)					changeState("dying");				else					changeState("idle");				curSegmentFrame = 1;				curSkillSegment = 0;				isAttacking = false;				this.removeEventListener(Event.ENTER_FRAME, executeSkill);				this.addEventListener(Event.ENTER_FRAME, everyFrame);								if (curDirection == "left")					this.scaleX = -_scale;				else					this.scaleX = _scale;				if (curTransform != "disable")					changeGenre(curTransform);			}					}		/**********************************************		**********************************************/	}	}