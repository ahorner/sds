/*Character.asCreated by: Andrew HornerContents:Character defines the base class for characters in the game. This class contains the basic attributes of a character, includinghealth, state, direction, hittable region, and variables used for determining what states are currently possible for the characterto enter.*/package character{		import flash.display.MovieClip;	import flash.display.Shape;	import flash.events.Event;		public class Character extends MovieClip	{				protected var curState:String = "idle";		protected var curDirection:String = "right";		protected var isDead = false;		protected var hitRegionBuffer:Number = 50;				protected var _maxHealth = 100;		protected var _health = 100;		protected var _defense = 2;		protected var _attackModifier = 1;				protected var _scale:Number = .35;		protected var _dY:Number = 0;		protected var _dX:Number = 0;		protected var _isGrounded:Boolean = false;				protected var _walkSpeed:Number = 3;		protected var _jumpHeight:Number = 28;				protected var _hitRegion:Shape = new Shape(); 				//Semi-temporary variables used for managing skill use and controls		protected var isAttacking:Boolean = false;		protected var curSkillSegment:Number = 0;		protected var curSegmentFrame:Number = 1;		protected var specificCommands:Array = new Array();				/**********************************************		Constructor method		**********************************************/		public function Character():void		{			super();			_hitRegion.graphics.drawRect(0, 0, this.width-hitRegionBuffer, this.height-hitRegionBuffer);			_hitRegion.x = 25-this.width/2;			_hitRegion.y = 25-this.height;			this.addChild(_hitRegion);			this.scale = _scale;			this.addEventListener(Event.ADDED, addHandler);		}						/**********************************************		The following define public methods of the 		Character class.		**********************************************/				/**********************************************		Getters and Setters		**********************************************/		public function get scale():Number		{			return _scale;		}				public function set scale(newScale:Number):void		{			_scale = newScale;			this.scaleX = _scale;			this.scaleY = _scale;		}				public function get maxHealth():Number		{			return _maxHealth;		}				public function set maxHealth(newMaxHealth:Number):void		{			_maxHealth = newMaxHealth;		}				public function get health():Number		{			return _health;		}				public function set health(newHealth:Number):void		{			_health = newHealth;			if (_health < 0)				_health = 0;			else if (_health > _maxHealth)				_health = _maxHealth;		}				public function get attack():Number		{			return _attackModifier;		}				public function set attack(newAttackMod:Number):void		{			_attackModifier = newAttackMod;		}				public function get defense():Number		{			return _defense;		}				public function set defense(newDefense:Number):void		{			_defense = newDefense;		}				public function get dY():Number		{			return _dY;		}				public function set dY(deltaY:Number):void		{			_dY = deltaY;		}				public function get dX():Number		{			return _dX;		}				public function set dX(deltaX:Number):void		{			_dX = deltaX;		}				public function get walkSpeed():Number		{			return _walkSpeed;		}				public function set walkSpeed(newWalkSpeed:Number):void		{			_walkSpeed = newWalkSpeed;		}				public function get jumpHeight():Number		{			return _jumpHeight;		}				public function set jumpHeight(newJumpHeight:Number):void		{			_jumpHeight = newJumpHeight;		}				public function get isGrounded():Boolean		{			return _isGrounded;		}				public function set isGrounded(onGround:Boolean):void		{			_isGrounded = onGround;		}				public function get hitRegion():Shape		{			return _hitRegion;		}				public function set hitRegion(newRegion:Shape):void		{			this.removeChild(_hitRegion);			_hitRegion = newRegion;			_hitRegion.x = hitRegionBuffer/2 - this.width/(2 * _scale);			_hitRegion.y = hitRegionBuffer/2 - this.height/_scale;			this.addChild(_hitRegion);		}		/*********************************************/				/*		Pre:	e refers to a HitEvent event		Post:	The character's health is reduced by the power of the hit, or reduced to 0 if the hit's power is greater than the remaining health		*/		public function hitHandler(e:HitEvent):void		{			var damage:Number = e.power - _defense;			if (e.power <= _defense && e.power != 0)				damage = 1;			else if (e.power == 0)				damage = 0;			health -= damage;		}				public function pauseCharacter():void		{			if (isAttacking)				this.removeEventListener(Event.ENTER_FRAME, executeSkill);			else				this.removeEventListener(Event.ENTER_FRAME, everyFrame);			this.stop();		}				public function resumeCharacter():void		{			this.play();			if (isAttacking)				this.addEventListener(Event.ENTER_FRAME, executeSkill);			else				this.addEventListener(Event.ENTER_FRAME, everyFrame);		}		/**********************************************		**********************************************/				/**********************************************		The following define private methods of the 		Character class.		**********************************************/				/*		Pre:	newState is a String containing the name of the state that the Character should transition to.		Post:	curState is updated to newState, and the character's movie clip transitions to the proper label		*/		protected function changeState(newState:String):void		{			curState = newState;			this.gotoAndPlay(curState);		}				/*		Pre:	e is a reference to an Event.ADDED event		Post:	If the event's target is this object, the event listener is removed, and listeners for 				Event.REMOVED and ENTER_FRAME events are added.		*/		protected function addHandler(e:Event):void		{			if (e.target == this)			{				this.removeEventListener(Event.ADDED, addHandler);				this.addEventListener(Event.REMOVED, removeHandler);				this.addEventListener(Event.ENTER_FRAME, everyFrame);			}		}				/*		Pre:	e is a reference to an Event.REMOVED event		Post:	If the event's target is this object, the Event.REMOVED and Event.ENTER_FRAME listeners are removed, 				and an Event.ADDED event listener is added.		*/		protected function removeHandler(e:Event):void		{			if (e.target == this)			{				this.removeEventListener(Event.ENTER_FRAME, everyFrame);				this.removeEventListener(Event.REMOVED, removeHandler);				this.addEventListener(Event.ADDED, addHandler);			}		}				/*		Pre:	e is a reference to an Event.ENTER_FRAME event		Post:	If the current label of the object is the end label for the current state, the animation is cycled back to the beginning.		*/		protected function everyFrame(e:Event):void		{			if (this.currentLabel == "end" + curState)				gotoAndPlay(curState);		}				/*		Pre:	e is an ENTER_FRAME Event, causing the movie clip to update on every frame		Post:	The clip cycles through its skill animation, dispatching AttackEvents to the level map in order to interact with enemies		*/		protected function executeSkill(e:Event):void		{			if (curSegmentFrame > specificCommands[curState].sequence["duration"][curSkillSegment])			{				curSegmentFrame = 1;				curSkillSegment++;				if (specificCommands[curState].sequence["duration"].length == curSkillSegment)					curSkillSegment = 0;			}						var attackType:String = specificCommands[curState].sequence["type"][curSkillSegment]			var power:Number = _attackModifier * specificCommands[curState].sequence["power"][curSkillSegment];			var knockback:Number = specificCommands[curState].sequence["knockback"][curSkillSegment];			var refArray:Array = specificCommands[curState].sequence["attributes"][curSkillSegment];			var signValue = Math.abs(this.scaleX)/this.scaleX;			knockback *= signValue;						var attackEvent:AttackEvent;						if (attackType == "hitBox")			{				var hitBox:Array = new Array();				hitBox[0] = refArray[0]*signValue*scale;				hitBox[1] = refArray[1]*scale;				hitBox[2] = refArray[2]*signValue*scale;				hitBox[3] = refArray[3]*scale;								attackEvent = new AttackEvent(this, attackType, power, knockback, hitBox);			}			else if (attackType == "hitRadius")			{				var hitCircle:Array = new Array();				hitCircle[0] = refArray[0]*signValue*scale;				hitCircle[1] = refArray[1]*scale;				hitCircle[2] = refArray[2]*scale;								attackEvent = new AttackEvent(this, attackType, power, knockback, hitCircle);			}			else if (attackType == "hitBullet")			{				var hitBullet:Array = new Array();				hitBullet[0] = refArray[0]*signValue*scale;				hitBullet[1] = refArray[1]*scale;				hitBullet[2] = refArray[2]*signValue;				hitBullet[3] = refArray[3];				hitBullet[4] = refArray[4];								attackEvent = new AttackEvent(this, attackType, power, knockback, hitBullet);			}						this.dispatchEvent(attackEvent);						curSegmentFrame++;		}		/**********************************************		**********************************************/	}}